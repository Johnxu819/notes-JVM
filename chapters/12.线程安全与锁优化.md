#线程安全与锁优化

##线程安全

对于线程安全《Java Concurrency In Practice》的作者Brian Goetz有一个计较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”

####java语言中的线程安全

线程安全并不一定是非真即假的，在java语言中按照线程安全的“安全程度”可以将分为5种：

1. 不可变
  * 在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施
2. 绝对线程安全
  * 绝对线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在java API中标注自己是线程安全的类，大多数都不是绝对线程安全
3. 相对线程安全
  * 相对线程安全就是通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全，在调用时不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性
4. 线程兼容
  * 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全地使用，平常说一个类不是线程安全的，绝大多数情况下是这种情况
5. 线程对立
  * 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免，线程对立说白了就是存在死锁风险

####线程安全的实现方法

1. 互斥同步
  * 互斥同步（Mutual Exclusion & Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个或者是一些（使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式 ==> synchronized，java.util.concurrent包
2. 非阻塞同步
  * 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。随着硬件指令集的发展，有了另外一个选择：基于冲突检测的乐观并发策略，即先进行操作，如果没有其他线程争用共享资源，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization） ==> 比较替换（Compare-and-Swap， CAS）
3. 无同步方案
  * 
##锁优化

####自旋锁与自适应自旋

####锁消除

####锁粗化

####轻量级锁

####偏向锁
