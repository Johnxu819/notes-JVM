#线程安全与锁优化

##线程安全

对于线程安全《Java Concurrency In Practice》的作者Brian Goetz有一个计较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”

####java语言中的线程安全

线程安全并不一定是非真即假的，在java语言中按照线程安全的“安全程度”可以将分为5种：

1. 不可变
  * 在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施
2. 绝对线程安全
  * 绝对线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在java API中标注自己是线程安全的类，大多数都不是绝对线程安全
3. 相对线程安全
  * 相对线程安全就是通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全，在调用时不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性
4. 线程兼容
  * 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全地使用，平常说一个类不是线程安全的，绝大多数情况下是这种情况
5. 线程对立
  * 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免，线程对立说白了就是存在死锁风险

####线程安全的实现方法

1. 互斥同步
  * 互斥同步（Mutual Exclusion & Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个或者是一些（使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式 ==> synchronized，java.util.concurrent包
2. 非阻塞同步
  * 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。随着硬件指令集的发展，有了另外一个选择：基于冲突检测的乐观并发策略，即先进行操作，如果没有其他线程争用共享资源，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization） ==> 比较替换（Compare-and-Swap， CAS）

##锁优化

####自旋锁与自适应自旋

自旋锁是指让线程执行一个忙循环（自旋），适用于锁占用时间很短的情况。对于锁占用情况很长情况，自旋的线程只会白白消耗处理器资源。因此，自旋等待的时间必须要有一定的限度，自旋次数的默认值是10次，我们可以使用参数-XX:PreBlockSpin来更改

在JDK1.6中引入了自适应的自旋锁，可以根据前一次在同一锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源

####锁消除

锁清除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁清除的主要判定依据来源于逃逸分析的数据分析，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，无须同步加锁

####轻量级锁

轻量级锁的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗

####偏向锁

偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步
